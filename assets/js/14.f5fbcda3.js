(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{108:function(t,v,_){"use strict";_.r(v);var e=_(0),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[t._v("#")]),t._v(" 索引")]),t._v(" "),e("p",[t._v("主要作用是为方便对某个 Metrics 下面 Tags 的 Filtering/Grouping 操作，同时也是为了提升整体的查询效率。")]),t._v(" "),e("p",[t._v("整个索引为一个倒排结构，类似 Lucene，但是相比会更加简单，因为在时序这样的场景不需要做分词这样的操作。下面以一个例子的方式来说明 Filtering/Grouping。")]),t._v(" "),e("h2",{attrs:{id:"filtering"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#filtering"}},[t._v("#")]),t._v(" Filtering")]),t._v(" "),e("p",[t._v("如下表为一个 Metrics(cpu) 下面 Tags 对应的正向数据，有 3 个 Tags 分别为 host/cpu/type")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Tags")]),t._v(" "),e("th",[t._v("Series ID")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("host=dev cpu=0 type=SCHED")]),t._v(" "),e("td",[t._v("1")])]),t._v(" "),e("tr",[e("td",[t._v("host=dev cpu=1 type=SCHED")]),t._v(" "),e("td",[t._v("2")])]),t._v(" "),e("tr",[e("td",[t._v("host=dev cpu=0 type=TIMER")]),t._v(" "),e("td",[t._v("3")])]),t._v(" "),e("tr",[e("td",[t._v("host=dev cpu=1 type=TIMER")]),t._v(" "),e("td",[t._v("4")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=0 type=SCHED")]),t._v(" "),e("td",[t._v("5")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=1 type=SCHED")]),t._v(" "),e("td",[t._v("6")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=2 type=SCHED")]),t._v(" "),e("td",[t._v("7")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=3 type=SCHED")]),t._v(" "),e("td",[t._v("8")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=0 type=TIMER")]),t._v(" "),e("td",[t._v("9")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=1 type=TIMER")]),t._v(" "),e("td",[t._v("10")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=2 type=TIMER")]),t._v(" "),e("td",[t._v("11")])]),t._v(" "),e("tr",[e("td",[t._v("host=test cpu=3 type=TIMER")]),t._v(" "),e("td",[t._v("12")])])])]),t._v(" "),e("p",[t._v("如果把上表的数据，倒排一下，就形成了如下表的倒排结构，Posting List 直接用 Roaring Bitmap 来存储。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Tag")]),t._v(" "),e("th",[t._v("Posting List")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("host=dev")]),t._v(" "),e("td",[t._v("1, 2, 3, 4")])]),t._v(" "),e("tr",[e("td",[t._v("host=test")]),t._v(" "),e("td",[t._v("5, 6, 7, 8, 9, 10, 11, 12")])]),t._v(" "),e("tr",[e("td",[t._v("cpu=0")]),t._v(" "),e("td",[t._v("1, 3, 5, 9")])]),t._v(" "),e("tr",[e("td",[t._v("cpu=1")]),t._v(" "),e("td",[t._v("2, 4, 6, 10")])]),t._v(" "),e("tr",[e("td",[t._v("cpu=2")]),t._v(" "),e("td",[t._v("7, 11")])]),t._v(" "),e("tr",[e("td",[t._v("cpu=3")]),t._v(" "),e("td",[t._v("8, 12")])]),t._v(" "),e("tr",[e("td",[t._v("type=SCHED")]),t._v(" "),e("td",[t._v("1, 2, 5, 6, 7, 8")])]),t._v(" "),e("tr",[e("td",[t._v("type=TIMER")]),t._v(" "),e("td",[t._v("3, 4, 9, 10, 11, 12")])])])]),t._v(" "),e("p",[t._v("同时对 Tag 下面的 Tag Values 以前缀树的方式存储，以方便对 Tag Value 做过滤操作，如 host like dev* 这样的前缀过滤操作。加上上面的倒排结构之后，对于条件过滤操作就非常方便，如多个条件的操作只需要对多个 Posting List 做 ”与“ / ”或“ 操作即可，基本可以满足日常多个条件的 And/Or/Not 这样的过滤操作。")]),t._v(" "),e("p",[t._v("例如：")]),t._v(" "),e("ul",[e("li",[t._v("Case 1:  host = test or host = dev，就是 2 个 Posting list 的 ”与“ 操作")]),t._v(" "),e("li",[t._v("Case 1:  host != test，这种就是找到 host 下面所的 Series IDs 和 host = test 的 Series IDs，把这 2 个 Posting list 求一个 AntNot(Difference) 操作即可")])]),t._v(" "),e("p",[t._v("同时基于这个倒排结构可能支持一些 Metadata 的查询，如想知道 host 这个 Tag 下面有哪些 Value 等。")]),t._v(" "),e("h2",{attrs:{id:"grouping"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#grouping"}},[t._v("#")]),t._v(" Grouping")]),t._v(" "),e("h3",{attrs:{id:"如何反推正向数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何反推正向数据"}},[t._v("#")]),t._v(" 如何反推正向数据")]),t._v(" "),e("p",[t._v("那么，如果不存储正向数据，怎么来解决按某个或者某几个 Tag Key 的 Group By 操作呢？如果我们像 Lucene 一样需要对 Tag Value 做分词的话，基本上是做不到通过反向来推导出正向的数据，但是在 TSDB 这样的场景里面，我们不需要对 Tag Value 做分词处理，所以还是可以通过反向的数据来反推出来正向的数据的。")]),t._v(" "),e("p",[e("img",{attrs:{src:_(68),alt:"index forward"}})]),t._v(" "),e("p",[t._v("下面还是拿之前那个例子来说明，怎么来拿到 Group By host,cpu 这 2 个 Tag Key 的数据，如上图所示，其实从图中可以看到，整个操作就是一个归并操作，有 2 种做法。")]),t._v(" "),e("ol",[e("li",[t._v("因为每个数据都是排好序的，所以可以用 2 个堆来排序，即 host 和 cpu 分别放在一个堆里面，每次从每个堆里面取一个值，如果值相同，说明 2 者都满足，如 TSID = 0 对应的 host=dev,cpu=0，即可以找到相应的 Group By 数据了，以此类推，遍历完 2 个堆里面的数据，就可以得到最终的结合，该方式会占用 CPU，内存占用少；")]),t._v(" "),e("li",[t._v("使用 Counting Sort，即预先分配好一个固定大小的数组，然后把 Series IDs 放在相应的数组下标里面，如下标为 1 中同时包括了 2 个 Tag Key 的数据，即是我们想要的，以此类推，可以拿到所有的数据，CPU 占用少，但是浪费内存；")])]),t._v(" "),e("p",[t._v("再结合，Roaring Bitmap High/Low Container 的结构，一个 Container 里最多可以有 65536 个值，所以内存的占用也可以得到控制，所以我们采用 Counting Sort 的方式来推导对应的正向数据，并且整体过程可以按一个个 Container 来并行处理。")]),t._v(" "),e("p",[t._v("参考引用")]),t._v(" "),e("ol",[e("li",[t._v("http://roaringbitmap.org/")]),t._v(" "),e("li",[t._v("https://akumuli.org/akumuli/2017/11/17/indexing/")])])])}),[],!1,null,null,null);v.default=s.exports},68:function(t,v,_){t.exports=_.p+"assets/img/index_forward.2956eca9.png"}}]);