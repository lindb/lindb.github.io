{"pageProps":{"page":{"path":"/docs/lindb/10-design/06-memory-database.mdx","meta":{"title":"内存数据库"},"title":"内存数据库","parent":"Design","commitInfo":{"author":"stone1100","date":"Mon Jun 24 07:03:27 2024"}},"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h2: \"h2\",\n    h5: \"h5\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"内存结构\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/memory_database.png\",\n        alt: \"内存数据库结构\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个内存结构更像是一个内存时序存储，主要包括如下 2 大块组成:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Metric Meta/Index: 主要存储了 Metric Metadata 和 Tags 的索引；\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Metric Metadata: 存储该 Metric 下面对应有哪些 Field 和哪些 Tag Keys，同时为每个 Tag Key 生成一个数据库级别的全局唯一的 ID，方便 Tag Index 在底层 KV Store 中的存储；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Metric Index: 主要是为每个 Metric Tag Key 下面的 Tag Values 做一个倒排索引，Term 是对应的 Tag Value, Posting List 为该 Metric 下对应的 Series ID ；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Hash(Tags) => Series ID: 通过 Tags Hash Code 计算相应的 Series ID 是否已经存在；\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Metric Store: 主要存储了 Metric 下面的数据，即该 Metric 下面的所有对应 Series 的每个 Field 的数据；\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Field List(Field Store): 根据不同的 Field Type 存储该 Field 的实际数据\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个内存结构中维护了上面 2 个数据结构的 2 个映射关系。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Series ID 的唯一性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"部分设计考虑了 OpenTSDB String => Int 的思路，考虑到时序数据的特点，Metric Name + Tags 这部分占用存储大头的数据存储在 Meta/Index 中： Filtering/Grouping 等操作将基于这部分数据来进行，实际存储数据时只存储到 Series ID 。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Metric 下的每一条 Series 线的唯一性通过 tags 来确定：对于 tags(ip=1.1.1.1, host=test.vm, zone=nt)，先根据 tagKey 作排序，得到 host=test.vm,ip=1.1.1.1,zone=nt 。如果原始存储 tags 文本到 Series ID 的映射关系，会浪费过多的存储空间。权衡效率后，LinDB 通过对 tags 计算 hash 来记录 Series，关于碰撞机率可参考\", _jsx(_components.a, {\n        href: \"https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/\",\n        children: \"生日碰撞\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一般化的哈希碰撞机率公式如下：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/hash_formula.png\",\n        alt: \"哈希碰撞机率公式\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通过以上公式，计算得 64 位 hash 在不同的 tags 组合数下的碰撞概率见下表。其中 d 为取值空间，n 为数据集规模。\\n在监控领域下，Metric 下 tags 的组合数极少能达到 1M 量级，即使在该量级碰撞机率也极低。\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Tags组合数量\"\n          }), _jsx(_components.th, {\n            children: \"至少有2条Series出现碰撞的机率\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"100K\"\n          }), _jsx(_components.td, {\n            children: \"0.000000000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"1M\"\n          }), _jsx(_components.td, {\n            children: \"0.0000000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"10M\"\n          }), _jsx(_components.td, {\n            children: \"0.00000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"100M\"\n          }), _jsx(_components.td, {\n            children: \"0.000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"1G\"\n          }), _jsx(_components.td, {\n            children: \"0.0271\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"写\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个写入流程如下:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"首先通过 Metric Name 查询是否存在对应的 Metric Meta；\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"存在: 使用 Metric Meta 中的数据，找到对应的 Field ID 和 Series ID，如果存在直接返回相应的 ID，如果没有对应的 Field ID 和 Series ID 的话先生成对应的 ID，同时往 Index 里面写入引索数据；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"不存在: 这种情况为一个新的 Metric, 返回生成对应的 ID，同时往 Index 里面写入引索数据；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Index 使用 Roaring Bitmap 为存储 Series ID Posting List；\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"拿到 Metric ID/Series ID 之后，就可以操作 Metric Store，找到对应的 Field Store 写入即可；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这里需要注意的地方有，如果直接使用 Map 来存储 Metric Store 里面的 Map 的话内存的开销还是比较大的，因为本身已经都转换成了  Int，所以这里可以使用 Roaring Bitmap + Array 的数据结构来构建一个 Map 结构，在 Roaring Bitmap 中存储所有 Keys 的值，Key 在 Roaring Bitmap 中的位置就是 Array 的 Index ，所以读取的效率也可以保证，同时可以与倒排索引里面 Roaring Bitmap 保持一致。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"深入 Roaring Bitmap 之后发现 Roaring Bitmap 内部是以 High Container + Low Container 的方式存储的，所以 Roaring Bitmap + Array 也可以使用这个思想来对进一步优化 Map 结构，即使用 Roaring Bitmap + []Array 的结构， Key 的高位使用 Roaring Bitmap 的 High Container 来存储， Key 的低位用 Low Container 来存储， Key 的高位对应一个 Array ，整体就是一个 2 维数组。这样就可以通过 Key 的高位来进行并行查询操作。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Flush\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"系统会定期检测当前系统中每个 Memory TSDB 是否已经超过了内存大，如果满足下面条件中的任何一种，都需要把内存中的数据 Flush 到磁盘上：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"单个 Memory TSDB 的内存占用超过指定大小；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"该个 Memory TSDB 距离上次 Flush 时间超过了一定的大小；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"该 LinDB 实例总内存占用超过一定大小之后，Flush 哪些占用内存比较大的 Memory TSDB，以防止该实例 OOM；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"文件结构请看 \", _jsx(_components.a, {\n        href: \"/docs/lindb/design/storage#sstable-layout\",\n        children: \"Storage SSTable\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"参考\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://opentsdb.net/docs/build/html/user_guide/uids.html\",\n          children: \"OpenTSDB UID\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/\",\n          children: \"Probability of secure hash collisions\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"tocItems":[{"id":"内存结构","level":2,"title":"内存结构"},{"id":"series-id-的唯一性","level":2,"title":"Series ID 的唯一性"},{"id":"写","level":2,"title":"写"},{"id":"flush","level":2,"title":"Flush"}],"releases":null,"sidebar":[{"index":2,"title":"Getting Started","children":[{"index":1,"title":"Docker","children":[],"href":"/docs/lindb/getting-started/docker"},{"index":2,"title":"安装包","children":[],"href":"/docs/lindb/getting-started/package"}]},{"index":3,"title":"Developer Guide","children":[{"index":1,"title":"建立连接","children":[],"href":"/docs/lindb/developer-guide/connect"},{"index":2,"title":"创建数据库","children":[],"href":"/docs/lindb/developer-guide/create-database"},{"index":3,"title":"写入数据","children":[],"href":"/docs/lindb/developer-guide/insert-data"},{"index":4,"title":"查询数据","children":[],"href":"/docs/lindb/developer-guide/query-data"}]},{"index":4,"title":"Deployment","children":[{"index":1,"title":"Kubernetes","children":[],"href":"/docs/lindb/deployment/kubernetes"},{"index":2,"title":"手动部署","children":[],"href":"/docs/lindb/deployment/manual"}]},{"index":5,"title":"Client","children":[{"index":1,"title":"CLI","children":[],"href":"/docs/lindb/client/cli"},{"index":2,"title":"客户端 SDK","children":[],"href":"/docs/lindb/client/client-libraries"},{"index":3,"title":"Go","children":[],"href":"/docs/lindb/client/go"},{"index":4,"title":"Java","children":[],"href":"/docs/lindb/client/java"}]},{"index":6,"title":"Lin Ql","children":[{"index":1,"title":"SQL","children":[],"href":"/docs/lindb/lin-ql/sql"}]},{"index":7,"title":"Admin Console","children":[{"index":1,"title":"简介","children":[],"href":"/docs/lindb/admin-console/index"},{"index":2,"title":"集群状态","children":[],"href":"/docs/lindb/admin-console/overview"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/admin-console/search"},{"index":4,"title":"数据浏览","children":[],"href":"/docs/lindb/admin-console/explore"},{"index":5,"title":"监控","children":[],"href":"/docs/lindb/admin-console/monitoring"},{"index":6,"title":"元数据","children":[],"href":"/docs/lindb/admin-console/metadata"}]},{"index":8,"title":"Api","children":[{"index":1,"title":"介绍","children":[],"href":"/docs/lindb/api/index"},{"index":2,"title":"数据写入","children":[],"href":"/docs/lindb/api/insert"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/api/query"},{"index":4,"title":"集群状态","children":[],"href":"/docs/lindb/api/state"}]},{"index":9,"title":"Reference","children":[{"index":1,"title":"数据模型","children":[],"href":"/docs/lindb/reference/data-model"},{"index":2,"title":"Metric","children":[],"href":"/docs/lindb/reference/metric"},{"index":3,"title":"配置参数","children":[],"href":"/docs/lindb/reference/configuration"}]},{"index":10,"title":"Design","children":[{"index":1,"title":"架构","children":[],"href":"/docs/lindb/design/architecture"},{"index":2,"title":"集群协调","children":[],"href":"/docs/lindb/design/coordinator"},{"index":3,"title":"数据复制","children":[],"href":"/docs/lindb/design/replication"},{"index":4,"title":"查询","children":[],"href":"/docs/lindb/design/query"},{"index":5,"title":"存储","children":[],"href":"/docs/lindb/design/storage"},{"index":6,"title":"内存数据库","children":[],"href":"/docs/lindb/design/memory-database"},{"index":7,"title":"例排索引","children":[],"href":"/docs/lindb/design/inverted-index"}]}],"locale":"zh","_nextI18Next":{"initialI18nStore":{"zh":{"translation":{"A lightweight, observability pipeline":"轻量级数据处理平台","A single server could easily support more than one million write TPS.":"机支持百万以上TPS写入；","Admin Console":"控制台","All-in-one observability platform":"一站式可观测平台","An open-source, cloud native, horizontally scalable, distributed time-series database.":"一款开源分布式时序数据库，具有高性能、高可用性和水平扩展性","An open-source, cloud native, observabilty platform":"云原生开源可观测平台","Architecture":"整体架构","Ask a Question":"提问","Auto Rollup":"自动 Rollup","Bug report":"发现 Bug","Client":"客户端","Cross Multiple IDCs":"跨多数据中心","Deployment":"集群部署","Design":"设计","Developer Guide":"开发手册","Distributed time-series database":"分布式时序数据库","Docs":"文档","Documentation":"文档","Downloads":"下载","Easy to use":"简单易用","Edit this page on Github":"在 GitHub 上编辑此页","Feature request":"新需求","Get Help":"获取帮助","Getting Started":"快速开始","High availability":"高可用","High performance":"高性能","Horizontal scalability":"水平扩展","Horizontal scalable is made simple by adding more new broker and storage nodes without too much thinking and manual operations Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Tags 级别的 Sharding 机制，可将任一 Metric 数据充分分散到多个存储节点；","Insert data":"数据写入","Inside LinDB":"技术内幕","Introduction":"介绍","Inverted index":"例排索引","Key Features":"主要功能","Learn More":"更多","License":"许可证","LinDB is designed to work under a Multi-Active IDCs cloud architecture. The compute layer of LinDB, called brokers, supports efficient Multi-IDCs aggregation query.":"支持各数据中心写入，多数据中心查询聚合；","LinDB supports rollup in specific intervals(minute, hour and day) automatically after creating the database(unlike the Continuous-Query of InfluxDB).":"支持秒级数据写入后自动Rollup到分钟、小时和天的粒度，无需人工介入（如 InfluxDB Continuous-Query）；","On this page":"本页导航","Open source":"开源","Query data":"数据查询","Read the installation guide for more information":{"":"查看安装手册了解更多信息。"},"Reference":"参考手册","Release Date":"发布时间","Release Note":"发布日志","Releases":"变更日志","Resources":"资源","Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Metric + Tags + Fields 的方式，无需提前定义 Schema；","Storage":"存储","Tags-based sharding strategy resolves the hotspot problem":"充分解决热点问题，可通过增加服务器数量线性增加处理能力；","The LinQL is flexible yet handy for real-time data analytics.":"可通过 LinQL 进行实时数据分析；","The multi-channel replication protocol supports any amount of nodes, ensures the system availability.":"独创的多通道复制协议支持任意节点数的多副本机制，可保证整个服务的高可用性；","This page could not be found":"找不到此页面","Uncompress":"解压","Version":"版本","View on GitHub":"GitHub","What's LinDB?":"什么是 LinDB？","What's New in":"","Why LinDB?":"为什么选择 LinDB？","With fundamental techniques like efficient compression storage and parallel computing, LinDB delivers highly optimized query performance.":"高效的数据压缩与多节点的并行查询与计算，专注查询性能优化；"}},"en":{"translation":{"Lin Ql":"Lin QL","Api":"API"}}},"initialLocale":"zh","ns":["translation"],"userConfig":null}},"__N_SSG":true}