{"pageProps":{"page":{"path":"/docs/lindb/10-design/06-memory-database.mdx","meta":{"title":"Memory database"},"title":"Memory database","parent":"Design","commitInfo":{"author":"stone1100","date":"Mon Jun 24 07:03:27 2024"}},"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    em: \"em\",\n    h2: \"h2\",\n    h4: \"h4\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Memory structure\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/memory_database.png\",\n        alt: \"Memory database\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The entire memory structure is more like a memory sequential storage, which mainly consists of the following \", _jsx(_components.strong, {\n        children: \"2\"\n      }), \" blocks:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Metric Meta/Index\"\n        }), \": It mainly stores the indexes of \", _jsx(_components.strong, {\n          children: \"Metric Metadata\"\n        }), \" and \", _jsx(_components.strong, {\n          children: \"Tags\"\n        }), \";\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Metric Metadata\"\n            }), \": Store which \", _jsx(_components.strong, {\n              children: \"Field\"\n            }), \" and which \", _jsx(_components.strong, {\n              children: \"Tag Keys\"\n            }), \" correspond to the \", _jsx(_components.strong, {\n              children: \"Metric\"\n            }), \", and generate a database-level globally unique \", _jsx(_components.strong, {\n              children: \"ID\"\n            }), \" for each \", _jsx(_components.strong, {\n              children: \"Tag Key\"\n            }), \", which is convenient for \", _jsx(_components.strong, {\n              children: \"Tag Index\"\n            }), \" Storage in the underlying \", _jsx(_components.strong, {\n              children: \"KV Store\"\n            }), \";\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Metric Index\"\n            }), \": Mainly to make an inverted index for the \", _jsx(_components.strong, {\n              children: \"Tag Values\"\n            }), \" under each \", _jsx(_components.strong, {\n              children: \"Metric Tag Key\"\n            }), \", \", _jsx(_components.strong, {\n              children: \"Term\"\n            }), \" is the corresponding \", _jsx(_components.strong, {\n              children: \"Tag Value\"\n            }), \", \", _jsx(_components.strong, {\n              children: \"Posting List\"\n            }), \" is the corresponding \", _jsx(_components.strong, {\n              children: \"Metric\"\n            }), \" \", _jsx(_components.strong, {\n              children: \"Series ID\"\n            }), \";\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Hash(Tags)\"\n            }), \" => \", _jsx(_components.strong, {\n              children: \"Series ID\"\n            }), \": Calculate whether the corresponding \", _jsx(_components.strong, {\n              children: \"Series ID\"\n            }), \" already exists through \", _jsx(_components.strong, {\n              children: \"Tags Hash Code\"\n            }), \";\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Metric Store\"\n        }), \": It mainly stores the data under the \", _jsx(_components.strong, {\n          children: \"Metric\"\n        }), \", that is, the data of each \", _jsx(_components.strong, {\n          children: \"Field\"\n        }), \" corresponding to the \", _jsx(_components.strong, {\n          children: \"Series\"\n        }), \" under the \", _jsx(_components.strong, {\n          children: \"Metric\"\n        }), \";\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Field List(Field Store)\"\n            }), \": Store the actual data of the \", _jsx(_components.strong, {\n              children: \"Field\"\n            }), \" according to different \", _jsx(_components.strong, {\n              children: \"Field Type\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.strong, {\n        children: \"2\"\n      }), \" mapping relationships of the \", _jsx(_components.strong, {\n        children: \"2\"\n      }), \" data structures above are maintained in the entire memory structure.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Uniqueness of series ID\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Part of the design considers the idea of \", _jsx(_components.strong, {\n        children: \"OpenTSDB String => Int\"\n      }), \", and considering the characteristics of time series data, the \", _jsx(_components.strong, {\n        children: \"Metric Name + Tags\"\n      }), \" part of the data that occupies the bulk of the storage is stored in \", _jsx(_components.strong, {\n        children: \"Meta/Index\"\n      }), \": \", _jsx(_components.strong, {\n        children: \"Filtering/Grouping\"\n      }), \" and other operations It will be based on this part of the data, and only store the \", _jsx(_components.strong, {\n        children: \"Series ID\"\n      }), \" when actually storing the data.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The uniqueness of each \", _jsx(_components.strong, {\n        children: \"Series\"\n      }), \" line under \", _jsx(_components.strong, {\n        children: \"Metric\"\n      }), \" is determined by \", _jsx(_components.strong, {\n        children: \"tags\"\n      }), \": for \", _jsx(_components.strong, {\n        children: \"tags(ip=1.1.1.1, host=test.vm, zone=nt)\"\n      }), \", first sort according to \", _jsx(_components.strong, {\n        children: \"tagKey\"\n      }), \" , get \", _jsx(_components.strong, {\n        children: \"host=test.vm,ip=1.1.1.1,zone=nt\"\n      }), \". If the mapping relationship between \", _jsx(_components.strong, {\n        children: \"tags\"\n      }), \" text and \", _jsx(_components.strong, {\n        children: \"Series ID\"\n      }), \" is stored originally, it will waste too much storage space. After weighing the efficiency, \", _jsx(_components.strong, {\n        children: \"LinDB\"\n      }), \" records the \", _jsx(_components.strong, {\n        children: \"Series\"\n      }), \" by calculating the \", _jsx(_components.strong, {\n        children: \"hash\"\n      }), \" of the \", _jsx(_components.strong, {\n        children: \"tags\"\n      }), \". For the collision probability, please refer to \", _jsx(_components.a, {\n        href: \"https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/\",\n        children: \"Birthday Collision\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The generalized hash collision probability formula is as follows:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/hash_formula.png\",\n        alt: \"hash formula\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Through the above formula, the calculated collision probability of \", _jsx(_components.strong, {\n        children: \"64\"\n      }), \"-bit \", _jsx(_components.strong, {\n        children: \"hash\"\n      }), \" under different combinations of \", _jsx(_components.strong, {\n        children: \"tags\"\n      }), \" is shown in the following table. where \", _jsx(_components.strong, {\n        children: \"d\"\n      }), \" is the value space and \", _jsx(_components.strong, {\n        children: \"n\"\n      }), \" is the size of the dataset.\\nIn the monitoring field, the number of combinations of \", _jsx(_components.strong, {\n        children: \"tags\"\n      }), \" under \", _jsx(_components.strong, {\n        children: \"Metric\"\n      }), \" can rarely reach the level of \", _jsx(_components.strong, {\n        children: \"1M\"\n      }), \", and even at this level, the collision probability is extremely low.\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Number of Tag combinations\"\n          }), _jsx(_components.th, {\n            children: \"Chance of collision with at least 2 Series\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"100K\"\n          }), _jsx(_components.td, {\n            children: \"0.000000000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"1M\"\n          }), _jsx(_components.td, {\n            children: \"0.0000000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"10M\"\n          }), _jsx(_components.td, {\n            children: \"0.00000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"100M\"\n          }), _jsx(_components.td, {\n            children: \"0.000271\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"1G\"\n          }), _jsx(_components.td, {\n            children: \"0.0271\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Write\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The entire writing process is as follows:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"First query whether there is a corresponding \", _jsx(_components.strong, {\n          children: \"Metric Meta\"\n        }), \" through \", _jsx(_components.strong, {\n          children: \"Metric Name\"\n        }), \";\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Exist: Use the data in \", _jsx(_components.strong, {\n              children: \"Metric Meta\"\n            }), \" to find the corresponding \", _jsx(_components.strong, {\n              children: \"Field ID\"\n            }), \" and \", _jsx(_components.strong, {\n              children: \"Series ID\"\n            }), \", if it exists, return the corresponding \", _jsx(_components.strong, {\n              children: \"ID\"\n            }), \" directly, if there is no corresponding \", _jsx(_components.strong, {\n              children: \"Field ID\"\n            }), \" and \", _jsx(_components.strong, {\n              children: \"Series ID\"\n            }), \", Mr. into the corresponding \", _jsx(_components.strong, {\n              children: \"ID\"\n            }), \", and at the same time write the index data into the \", _jsx(_components.strong, {\n              children: \"Index\"\n            }), \";\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Does not exist: In this case, it is a new \", _jsx(_components.strong, {\n              children: \"Metric\"\n            }), \", return the corresponding \", _jsx(_components.strong, {\n              children: \"ID\"\n            }), \", and write the index data into \", _jsx(_components.strong, {\n              children: \"Index\"\n            }), \" at the same time;\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"Index\"\n            }), \" uses \", _jsx(_components.strong, {\n              children: \"Roaring Bitmap\"\n            }), \" to store \", _jsx(_components.strong, {\n              children: \"Series ID Posting List\"\n            }), \";\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"After getting the \", _jsx(_components.strong, {\n          children: \"Metric ID/Series ID\"\n        }), \", you can operate the \", _jsx(_components.strong, {\n          children: \"Metric Store\"\n        }), \" and find the corresponding \", _jsx(_components.strong, {\n          children: \"Field Store\"\n        }), \" to write;\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The points to note here are that if you directly use \", _jsx(_components.strong, {\n        children: \"Map\"\n      }), \" to store \", _jsx(_components.strong, {\n        children: \"Map\"\n      }), \" in \", _jsx(_components.strong, {\n        children: \"Metric Store\"\n      }), \", the memory overhead is still relatively large, because it has been converted into \", _jsx(_components.strong, {\n        children: \"Int\"\n      }), \", so \", _jsx(_components.strong, {\n        children: \"Roaring\"\n      }), \" can be used here. Bitmap + Array** data structure to build a \", _jsx(_components.strong, {\n        children: \"Map\"\n      }), \" structure, store all \", _jsx(_components.strong, {\n        children: \"Keys\"\n      }), \" values ​​in \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \", the position of \", _jsx(_components.strong, {\n        children: \"Key\"\n      }), \" in \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \" is \", _jsx(_components.strong, {\n        children: \"Index\"\n      }), \" of \", _jsx(_components.strong, {\n        children: \"Array\"\n      }), \", so The efficiency of reading can also be guaranteed, and it can be consistent with the \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \" in the inverted index.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"After delving into \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \", it is found that \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \" is stored in the form of \", _jsx(_components.strong, {\n        children: \"High Container + Low Container\"\n      }), \", so \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap + Array\"\n      }), \" can also use this idea to further optimize the \", _jsx(_components.strong, {\n        children: \"Map\"\n      }), \" structure, that is, use ** The structure of Roaring Bitmap + []Array**, the high bit of \", _jsx(_components.strong, {\n        children: \"Key\"\n      }), \" is stored in \", _jsx(_components.strong, {\n        children: \"High Container\"\n      }), \" of \", _jsx(_components.strong, {\n        children: \"Roaring Bitmap\"\n      }), \", the low bit of \", _jsx(_components.strong, {\n        children: \"Key\"\n      }), \" is stored in \", _jsx(_components.strong, {\n        children: \"Low Container\"\n      }), \", the high bit of \", _jsx(_components.strong, {\n        children: \"Key\"\n      }), \" corresponds to an \", _jsx(_components.strong, {\n        children: \"Array\"\n      }), \" **, the whole is a \", _jsx(_components.strong, {\n        children: \"2\"\n      }), \"-dimensional array. In this way, parallel query operations can be performed through the high bits of \", _jsx(_components.strong, {\n        children: \"Key\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Flush\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The system will periodically check whether each \", _jsx(_components.strong, {\n        children: \"Memory TSDB\"\n      }), \" in the current system has exceeded the memory size. If any of the following conditions are met, the data in the memory needs to be \", _jsx(_components.strong, {\n        children: \"Flush\"\n      }), \" to the disk:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"The memory usage of a single \", _jsx(_components.strong, {\n          children: \"Memory TSDB\"\n        }), \" exceeds the specified size;\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"The \", _jsx(_components.strong, {\n          children: \"Memory TSDB\"\n        }), \" has exceeded a certain size since the last \", _jsx(_components.strong, {\n          children: \"Flush\"\n        }), \";\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"After the total memory usage of the \", _jsx(_components.strong, {\n          children: \"LinDB\"\n        }), \" instance exceeds a certain size, \", _jsx(_components.strong, {\n          children: \"Flush\"\n        }), \" which occupies a large amount of memory \", _jsx(_components.strong, {\n          children: \"Memory TSDB\"\n        }), \" to prevent the instance \", _jsx(_components.strong, {\n          children: \"OOM\"\n        }), \";\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"See \", _jsx(_components.a, {\n        href: \"./storage#sstable-layout\",\n        children: \"Storage SSTable\"\n      }), \" for the file structure.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Reference\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://opentsdb.net/docs/build/html/user_guide/uids.html\",\n          children: _jsx(_components.em, {\n            children: \"OpenTSDB UID\"\n          })\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/\",\n          children: _jsx(_components.em, {\n            children: \"Probability of secure hash collisions\"\n          })\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.wangbase.com/blogimg/asset/201809/bg2018090508.png\",\n          children: _jsx(_components.em, {\n            children: \"Hash collision probability formula\"\n          })\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"tocItems":[{"id":"memory-structure","level":2,"title":"Memory structure"},{"id":"uniqueness-of-series-id","level":2,"title":"Uniqueness of series ID"},{"id":"write","level":2,"title":"Write"},{"id":"flush","level":2,"title":"Flush"}],"releases":null,"sidebar":[{"index":2,"title":"Getting Started","children":[{"index":1,"title":"Docker","children":[],"href":"/docs/lindb/getting-started/docker"},{"index":2,"title":"Package","children":[],"href":"/docs/lindb/getting-started/package"}]},{"index":3,"title":"Developer Guide","children":[{"index":1,"title":"Connect","children":[],"href":"/docs/lindb/developer-guide/connect"},{"index":2,"title":"Create a database","children":[],"href":"/docs/lindb/developer-guide/create-database"},{"index":3,"title":"Insert data","children":[],"href":"/docs/lindb/developer-guide/insert-data"},{"index":4,"title":"Query data","children":[],"href":"/docs/lindb/developer-guide/query-data"}]},{"index":4,"title":"Deployment","children":[{"index":1,"title":"Kubernetes","children":[],"href":"/docs/lindb/deployment/kubernetes"},{"index":2,"title":"Manual deployment","children":[],"href":"/docs/lindb/deployment/manual"}]},{"index":5,"title":"Client","children":[{"index":1,"title":"CLI","children":[],"href":"/docs/lindb/client/cli"},{"index":2,"title":"Client libraries","children":[],"href":"/docs/lindb/client/client-libraries"},{"index":3,"title":"Go","children":[],"href":"/docs/lindb/client/go"},{"index":4,"title":"Java","children":[],"href":"/docs/lindb/client/java"}]},{"index":6,"title":"Lin Ql","children":[{"index":1,"title":"Lin query language","children":[],"href":"/docs/lindb/lin-ql/sql"}]},{"index":7,"title":"Admin Console","children":[{"index":1,"title":"Introduction","children":[],"href":"/docs/lindb/admin-console/index"},{"index":2,"title":"Cluster overview","children":[],"href":"/docs/lindb/admin-console/overview"},{"index":3,"title":"Data search","children":[],"href":"/docs/lindb/admin-console/search"},{"index":4,"title":"Data explore","children":[],"href":"/docs/lindb/admin-console/explore"},{"index":5,"title":"Cluster monitoring","children":[],"href":"/docs/lindb/admin-console/monitoring"},{"index":6,"title":"Metadata","children":[],"href":"/docs/lindb/admin-console/metadata"}]},{"index":8,"title":"Api","children":[{"index":1,"title":"Introduction","children":[],"href":"/docs/lindb/api/index"},{"index":2,"title":"Insert","children":[],"href":"/docs/lindb/api/insert"},{"index":3,"title":"Query","children":[],"href":"/docs/lindb/api/query"},{"index":4,"title":"State","children":[],"href":"/docs/lindb/api/state"}]},{"index":9,"title":"Reference","children":[{"index":1,"title":"Data Model","children":[],"href":"/docs/lindb/reference/data-model"},{"index":2,"title":"Metric","children":[],"href":"/docs/lindb/reference/metric"},{"index":3,"title":"Configuration","children":[],"href":"/docs/lindb/reference/configuration"}]},{"index":10,"title":"Design","children":[{"index":1,"title":"Architecture","children":[],"href":"/docs/lindb/design/architecture"},{"index":2,"title":"Coordinator","children":[],"href":"/docs/lindb/design/coordinator"},{"index":3,"title":"Replication","children":[],"href":"/docs/lindb/design/replication"},{"index":4,"title":"Query","children":[],"href":"/docs/lindb/design/query"},{"index":5,"title":"Storage","children":[],"href":"/docs/lindb/design/storage"},{"index":6,"title":"Memory database","children":[],"href":"/docs/lindb/design/memory-database"},{"index":7,"title":"Inverted index","children":[],"href":"/docs/lindb/design/inverted-index"}]}],"locale":"","_nextI18Next":{"initialI18nStore":{"en":{"translation":{"Lin Ql":"Lin QL","Api":"API"}}},"initialLocale":"en","ns":["translation"],"userConfig":null}},"__N_SSG":true}