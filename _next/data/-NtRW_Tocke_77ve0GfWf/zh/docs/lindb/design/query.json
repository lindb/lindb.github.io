{"pageProps":{"page":{"path":"/docs/lindb/10-design/04-query.mdx","meta":{"title":"查询"},"title":"查询","parent":"Design","commitInfo":{"author":"stone1100","date":"Mon Jun 24 07:03:27 2024"}},"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h2: \"h2\",\n    h6: \"h6\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"概览\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"参与查询的角色如下：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Broker : 接收用户的查询，根据查询语句生成相应的执行计划，并下发到相应的 Storage 节点，同时会聚合各 Storage 节点返回的结果，生成最终的结果；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Storage : 执行数据的过滤， DownSampling 和最简单的原子计算（即有一定的算子下推的能力）；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个查询顺序如下，这里不分是在 Broker 还是 Storage 上执行，只看整个查询过程：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Query Language Plan\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Filtering\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Scan Time Series\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Grouping if need\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DownSampling\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Aggregation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Functions\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Expressions\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由于 LinDB 是用 Golang 实现，因此可以通过 Goroutine 就能很好的支持一个异步操作及高并发，但系统还是采用了 Goroutine Pool 的概念来更好的管理及处理这些异步 Task 。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个查询过程都是异步完成，以异步 Task 的方式工作，即 Task A 只做一件事情，Task A 的结果可能是 Task B 的 Input ，但是  Task B 不会等待 Task A 结果的到来，而是以 Event 的方式 Trigger Task B，最终完成一个查询 Pipeline 执行。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这里需要特别说明的是，系统不会开几个 Goroutine 来完成一个请求，而是在不同的 Goroutine Pool 中完成，所有的 Task 都是没有返回值的，以 Event Driver 的方式进行处理。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面举一个例子来说明，例如 Scan Goroutine Pool 只做 Scan 的操作，而不是启了一个 Goroutine Scan 数据，等待下一个 Task 结果再返回给上层 Task 来做合并，这样整个处理过程中各 Goroutine 还是会有等待行为，而是直接把 Scan 的结果直接给下一个 Task ，数据合并有专门的 Task 来完成，这样的好处是 Scan Goroutine 完成一个 Scan 操作之后，又可以做下一个 Scan 操作，可以更充分的利用系统资源。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"尽量通过 Streaming 的方式来完成整个查询过程，以减少没有必要的对象创建带来的 GC 压力，同时也会对一些可以复用并且高频的对象进行 Pool 化，以提升内存的使用率。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"根据不同的查询条件，可以 Plan 出如下几大类型的执行计划：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Simple Query : 简单的聚合查询；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Complex Query : 带 Grouping 的查询；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Cross IDC Query : 跨 IDC 之间的查询；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"简单查询\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/simple_query.png\",\n        alt: \"简单查询\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"接收到用户请求的 Broker 节点作为 Root 节点，根据当前所需要查询的 Database 状态，执行 Plan 操作，并生成执行计划，并把查询请求发送给 Storage 集群相关的节点（Leaf 节点）执行;\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Leaf 节点根据查询条件执行 Filtering=>Scan=>Downsampling=>Aggreation 等操作；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"由于没有 Grouping 操作，因此最终的结果可以直接返回给 Root 节点进行最终的聚合操作，并把最终结果返回给用户；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"复杂查询\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/complex_query.png\",\n        alt: \"复杂查询\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由于很多场景都需要通过 Grouping 来做更复杂的分析，有时还需要通过 Top N 求相应的数据，这时会返回大量的 Grouping 之后的数据，如果此时再把这些数据返回给一个计算节点的话，可能导致这个节点的内存成为瓶颈，为了解决这种场景带来的问题，引入了  Intermediate Broker 节点参与中间结果的计算，即：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"多台计算节点协同参与部分 Grouping 的计算；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"单机 Storage 节点向 Broker 节点发送数据时流式小批量发送，避免单节点 Storage 因查询数据过多而导致 GC 加剧甚至 OOM ；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整体处理过程如下：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Root Broker 节点，根据集群计算并行度选择特定的 Intermediate Broker 来参与部分 Grouping 计算；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Root 首先将请求下发给 Intermediate Broker ，再由 Intermediate Broker 下发任务给 Storage 节点，同时会带上所有 Intermediate Broker 信息，这样 Storage 节点就知道应该把结果数据回传给哪些节点；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Storage 会按 Grouping 之后 Series 的 hash 值，把数据 Sharding 到指定的 Intermediate Broker 节点上，这样便能将相同的 Series 数据 Sharding 到同一台 Intermediate Broker 上进行 Aggregation 操作，以提高数据聚合的局部性，并保证数据的一致性；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Intermediate Broker 收到数据后先进行数据的聚合，当查询信息中的所有 Storage 均已发送数据完毕后，说明完成了数据的聚合，然后开始进行表达式计算。表达式计算中可能包含局部排序，完成计算之后将结果发给 Root ；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Root 进行最终的数据合并及排序操作，生成最终结果给用户；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"跨机房查询\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/cross_idc_query.png\",\n        alt: \"跨机房查询\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"LinDB 的跨 IDC 是做在 Query 层，因此可以把此类查询理解为把上面 2 种查询下发到各 IDC 之后的再在 Root 节点上做最终的聚合操作；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"异常处理\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"查询超时或者异常导致部分节点没有把数据返回给上游节点，导致上游节点的 Task 一直是 Pending 状态，因此每个节点都会有一个 Task Manager 来管理每个请求处理的所有 Task 状态，来处理异常 Task\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"部分 Storage 节点有时由于没有对应的数据返回 Not Found ，需要处理这类异常；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"正常异常处理；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h6, {\n      children: \"参考\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://eng.uber.com/billion-data-point-challenge/\",\n          children: \"M3DB: Building a Query Engine for High Cardinality Time Series Data\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://drill.apache.org/docs/drill-query-execution/\",\n          children: \"Drill Query Execution\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"tocItems":[{"id":"概览","level":2,"title":"概览"},{"id":"简单查询","level":2,"title":"简单查询"},{"id":"复杂查询","level":2,"title":"复杂查询"},{"id":"跨机房查询","level":2,"title":"跨机房查询"},{"id":"异常处理","level":2,"title":"异常处理"}],"releases":null,"sidebar":[{"index":2,"title":"Getting Started","children":[{"index":1,"title":"Docker","children":[],"href":"/docs/lindb/getting-started/docker"},{"index":2,"title":"安装包","children":[],"href":"/docs/lindb/getting-started/package"}]},{"index":3,"title":"Developer Guide","children":[{"index":1,"title":"建立连接","children":[],"href":"/docs/lindb/developer-guide/connect"},{"index":2,"title":"创建数据库","children":[],"href":"/docs/lindb/developer-guide/create-database"},{"index":3,"title":"写入数据","children":[],"href":"/docs/lindb/developer-guide/insert-data"},{"index":4,"title":"查询数据","children":[],"href":"/docs/lindb/developer-guide/query-data"}]},{"index":4,"title":"Deployment","children":[{"index":1,"title":"Kubernetes","children":[],"href":"/docs/lindb/deployment/kubernetes"},{"index":2,"title":"手动部署","children":[],"href":"/docs/lindb/deployment/manual"}]},{"index":5,"title":"Client","children":[{"index":1,"title":"CLI","children":[],"href":"/docs/lindb/client/cli"},{"index":2,"title":"客户端 SDK","children":[],"href":"/docs/lindb/client/client-libraries"},{"index":3,"title":"Go","children":[],"href":"/docs/lindb/client/go"},{"index":4,"title":"Java","children":[],"href":"/docs/lindb/client/java"}]},{"index":6,"title":"Lin Ql","children":[{"index":1,"title":"SQL","children":[],"href":"/docs/lindb/lin-ql/sql"}]},{"index":7,"title":"Admin Console","children":[{"index":1,"title":"简介","children":[],"href":"/docs/lindb/admin-console/index"},{"index":2,"title":"集群状态","children":[],"href":"/docs/lindb/admin-console/overview"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/admin-console/search"},{"index":4,"title":"数据浏览","children":[],"href":"/docs/lindb/admin-console/explore"},{"index":5,"title":"监控","children":[],"href":"/docs/lindb/admin-console/monitoring"},{"index":6,"title":"元数据","children":[],"href":"/docs/lindb/admin-console/metadata"}]},{"index":8,"title":"Api","children":[{"index":1,"title":"介绍","children":[],"href":"/docs/lindb/api/index"},{"index":2,"title":"数据写入","children":[],"href":"/docs/lindb/api/insert"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/api/query"},{"index":4,"title":"集群状态","children":[],"href":"/docs/lindb/api/state"}]},{"index":9,"title":"Reference","children":[{"index":1,"title":"数据模型","children":[],"href":"/docs/lindb/reference/data-model"},{"index":2,"title":"Metric","children":[],"href":"/docs/lindb/reference/metric"},{"index":3,"title":"配置参数","children":[],"href":"/docs/lindb/reference/configuration"}]},{"index":10,"title":"Design","children":[{"index":1,"title":"架构","children":[],"href":"/docs/lindb/design/architecture"},{"index":2,"title":"集群协调","children":[],"href":"/docs/lindb/design/coordinator"},{"index":3,"title":"数据复制","children":[],"href":"/docs/lindb/design/replication"},{"index":4,"title":"查询","children":[],"href":"/docs/lindb/design/query"},{"index":5,"title":"存储","children":[],"href":"/docs/lindb/design/storage"},{"index":6,"title":"内存数据库","children":[],"href":"/docs/lindb/design/memory-database"},{"index":7,"title":"例排索引","children":[],"href":"/docs/lindb/design/inverted-index"}]}],"locale":"zh","_nextI18Next":{"initialI18nStore":{"zh":{"translation":{"A lightweight, observability pipeline":"轻量级数据处理平台","A single server could easily support more than one million write TPS.":"机支持百万以上TPS写入；","Admin Console":"控制台","All-in-one observability platform":"一站式可观测平台","An open-source, cloud native, horizontally scalable, distributed time-series database.":"一款开源分布式时序数据库，具有高性能、高可用性和水平扩展性","An open-source, cloud native, observabilty platform":"云原生开源可观测平台","Architecture":"整体架构","Ask a Question":"提问","Auto Rollup":"自动 Rollup","Bug report":"发现 Bug","Client":"客户端","Cross Multiple IDCs":"跨多数据中心","Deployment":"集群部署","Design":"设计","Developer Guide":"开发手册","Distributed time-series database":"分布式时序数据库","Docs":"文档","Documentation":"文档","Downloads":"下载","Easy to use":"简单易用","Edit this page on Github":"在 GitHub 上编辑此页","Feature request":"新需求","Get Help":"获取帮助","Getting Started":"快速开始","High availability":"高可用","High performance":"高性能","Horizontal scalability":"水平扩展","Horizontal scalable is made simple by adding more new broker and storage nodes without too much thinking and manual operations Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Tags 级别的 Sharding 机制，可将任一 Metric 数据充分分散到多个存储节点；","Insert data":"数据写入","Inside LinDB":"技术内幕","Introduction":"介绍","Inverted index":"例排索引","Key Features":"主要功能","Learn More":"更多","License":"许可证","LinDB is designed to work under a Multi-Active IDCs cloud architecture. The compute layer of LinDB, called brokers, supports efficient Multi-IDCs aggregation query.":"支持各数据中心写入，多数据中心查询聚合；","LinDB supports rollup in specific intervals(minute, hour and day) automatically after creating the database(unlike the Continuous-Query of InfluxDB).":"支持秒级数据写入后自动Rollup到分钟、小时和天的粒度，无需人工介入（如 InfluxDB Continuous-Query）；","On this page":"本页导航","Open source":"开源","Query data":"数据查询","Read the installation guide for more information":{"":"查看安装手册了解更多信息。"},"Reference":"参考手册","Release Date":"发布时间","Release Note":"发布日志","Releases":"变更日志","Resources":"资源","Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Metric + Tags + Fields 的方式，无需提前定义 Schema；","Storage":"存储","Tags-based sharding strategy resolves the hotspot problem":"充分解决热点问题，可通过增加服务器数量线性增加处理能力；","The LinQL is flexible yet handy for real-time data analytics.":"可通过 LinQL 进行实时数据分析；","The multi-channel replication protocol supports any amount of nodes, ensures the system availability.":"独创的多通道复制协议支持任意节点数的多副本机制，可保证整个服务的高可用性；","This page could not be found":"找不到此页面","Uncompress":"解压","Version":"版本","View on GitHub":"GitHub","What's LinDB?":"什么是 LinDB？","What's New in":"","Why LinDB?":"为什么选择 LinDB？","With fundamental techniques like efficient compression storage and parallel computing, LinDB delivers highly optimized query performance.":"高效的数据压缩与多节点的并行查询与计算，专注查询性能优化；"}},"en":{"translation":{"Lin Ql":"Lin QL","Api":"API"}}},"initialLocale":"zh","ns":["translation"],"userConfig":null}},"__N_SSG":true}