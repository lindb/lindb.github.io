import{_ as r}from"./memory_database.77ca8c20.js";import{_ as a,r as i,o as s,c as n,d as e,a as t,w as h,F as l,b as u,e as o}from"./app.1245c310.js";const m={},p=u('<h1 id="memory-database" tabindex="-1"><a class="header-anchor" href="#memory-database" aria-hidden="true">#</a> Memory Database</h1><h2 id="memory-structure" tabindex="-1"><a class="header-anchor" href="#memory-structure" aria-hidden="true">#</a> memory structure</h2><p><img src="'+r+'" alt="memory overview"></p><p>The entire memory structure is more like a memory sequential storage, which mainly consists of the following <code>2</code> blocks:</p><ol><li><code>Metric Meta/Index</code>: It mainly stores the indexes of <code>Metric Metadata</code> and <code>Tags</code>; <ul><li><code>Metric Metadata</code>: Store which <code>Field</code> and which <code>Tag Keys</code> correspond to the <code>Metric</code>, and generate a database-level globally unique <code>ID</code> for each <code>Tag Key</code>, which is convenient for <code>Tag Index</code> Storage in the underlying <code>KV Store</code>;</li><li><code>Metric Index</code>: Mainly to make an inverted index for the <code>Tag Values</code> under each <code>Metric Tag Key</code>, <code>Term</code> is the corresponding <code>Tag Value</code>, <code>Posting List</code> is the corresponding <code>Metric</code> <code>Series ID</code>;</li><li><code>Hash(Tags)</code> =&gt; <code>Series ID</code>: Calculate whether the corresponding <code>Series ID</code> already exists through <code>Tags Hash Code</code>;</li></ul></li><li><code>Metric Store</code>: It mainly stores the data under the <code>Metric</code>, that is, the data of each <code>Field</code> corresponding to the <code>Series</code> under the <code>Metric</code>; <ul><li><code>Field List(Field Store)</code>: Store the actual data of the <code>Field</code> according to different <code>Field Type</code></li></ul></li></ol><p>The <code>2</code> mapping relationships of the <code>2</code> data structures above are maintained in the entire memory structure.</p><h2 id="uniqueness-of-series-id" tabindex="-1"><a class="header-anchor" href="#uniqueness-of-series-id" aria-hidden="true">#</a> Uniqueness of Series ID</h2><p>Part of the design considers the idea of \u200B\u200B<code>OpenTSDB String =&gt; Int</code>, and considering the characteristics of time series data, the <code>Metric Name + Tags</code> part of the data that occupies the bulk of the storage is stored in <code>Meta/Index</code>: <code>Filtering/Grouping</code> and other operations It will be based on this part of the data, and only store the <code>Series ID</code> when actually storing the data.</p><p>The uniqueness of each <code>Series</code> line under <code>Metric</code> is determined by <code>tags</code>: for <code>tags(ip=1.1.1.1, host=test.vm, zone=nt)</code>, first sort according to <code>tagKey</code> , get <code>host=test.vm,ip=1.1.1.1,zone=nt</code>. If the mapping relationship between <code>tags</code> text and <code>Series ID</code> is stored originally, it will waste too much storage space. After weighing the efficiency, <code>LinDB</code> records the <code>Series</code> by calculating the <code>hash</code> of the <code>tags</code>. For the collision probability, please refer to [Birthday Collision](https://www.johndcook.com/blog/2017/01/10/ probability-of-secure-hash-collisions/)</p><p>The generalized hash collision probability formula is as follows:</p><p><img src="https://www.wangbase.com/blogimg/asset/201809/bg2018090508.png" alt="Hash collision probability formula"></p><p>Through the above formula, the calculated collision probability of <code>64</code>-bit <code>hash</code> under different combinations of <code>tags</code> is shown in the following table. where <code>d</code> is the value space and <code>n</code> is the size of the dataset. In the monitoring field, the number of combinations of <code>tags</code> under <code>Metric</code> can rarely reach the level of <code>1M</code>, and even at this level, the collision probability is extremely low.</p><table><thead><tr><th>Number of Tag combinations</th><th>Chance of collision with at least 2 Series</th></tr></thead><tbody><tr><td>100K</td><td>0.000000000271</td></tr><tr><td>1M</td><td>0.0000000271</td></tr><tr><td>10M</td><td>0.00000271</td></tr><tr><td>100M</td><td>0.000271</td></tr><tr><td>1G</td><td>0.0271</td></tr></tbody></table><h2 id="write" tabindex="-1"><a class="header-anchor" href="#write" aria-hidden="true">#</a> Write</h2><p>The entire writing process is as follows:</p><ol><li>First query whether there is a corresponding <code>Metric Meta</code> through <code>Metric Name</code>; <ul><li>Exist: Use the data in <code>Metric Meta</code> to find the corresponding <code>Field ID</code> and <code>Series ID</code>, if it exists, return the corresponding <code>ID</code> directly, if there is no corresponding <code>Field ID</code> and <code>Series ID</code>, Mr. into the corresponding <code>ID</code>, and at the same time write the index data into the <code>Index</code>;</li><li>Does not exist: In this case, it is a new <code>Metric</code>, return the corresponding <code>ID</code>, and write the index data into <code>Index</code> at the same time;</li><li><code>Index</code> uses <code>Roaring Bitmap</code> to store <code>Series ID Posting List</code>;</li></ul></li><li>After getting the <code>Metric ID/Series ID</code>, you can operate the <code>Metric Store</code> and find the corresponding <code>Field Store</code> to write;</li></ol><p>The points to note here are that if you directly use <code>Map</code> to store <code>Map</code> in <code>Metric Store</code>, the memory overhead is still relatively large, because it has been converted into <code>Int</code>, so <code>Roaring</code> can be used here. Bitmap + Array<code>data structure to build a</code>Map<code>structure, store all</code>Keys<code>values \u200B\u200Bin</code>Roaring Bitmap<code>, the position of </code>Key<code>in</code>Roaring Bitmap<code>is</code>Index<code>of</code>Array<code>, so The efficiency of reading can also be guaranteed, and it can be consistent with the </code>Roaring Bitmap` in the inverted index.</p><p>After delving into <code>Roaring Bitmap</code>, it is found that <code>Roaring Bitmap</code> is stored in the form of <code>High Container + Low Container</code>, so <code>Roaring Bitmap + Array</code> can also use this idea to further optimize the <code>Map</code> structure, that is, use <code> The structure of Roaring Bitmap + []Array</code>, the high bit of <code>Key</code> is stored in <code>High Container</code> of <code>Roaring Bitmap</code>, the low bit of <code>Key</code> is stored in <code>Low Container</code>, the high bit of <code>Key</code> corresponds to an <code>Array</code> <code>, the whole is a </code>2<code>-dimensional array. In this way, parallel query operations can be performed through the high bits of </code>Key`.</p><h2 id="flush" tabindex="-1"><a class="header-anchor" href="#flush" aria-hidden="true">#</a> Flush</h2><p>The system will periodically check whether each <code>Memory TSDB</code> in the current system has exceeded the memory size. If any of the following conditions are met, the data in the memory needs to be <code>Flush</code> to the disk:</p><ol><li>The memory usage of a single <code>Memory TSDB</code> exceeds the specified size;</li><li>The <code>Memory TSDB</code> has exceeded a certain size since the last <code>Flush</code>;</li><li>After the total memory usage of the <code>LinDB</code> instance exceeds a certain size, <code>Flush</code> which occupies a large amount of memory <code>Memory TSDB</code> to prevent the instance <code>OOM</code>;</li></ol>',21),f=o("See "),g=o("Storage SSTable"),y=o(" for the file structure."),b=e("h4",{id:"refer-to",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#refer-to","aria-hidden":"true"},"#"),o(" refer to")],-1),w={href:"http://opentsdb.net/docs/build/html/user_guide/uids.html",target:"_blank",rel:"noopener noreferrer"},M=o("OpenTSDB UID"),_={href:"https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/",target:"_blank",rel:"noopener noreferrer"},I=o("Probability of secure hash collisions");function x(S,T){const c=i("RouterLink"),d=i("ExternalLinkIcon");return s(),n(l,null,[p,e("p",null,[f,t(c,{to:"/design/storage.html#sstable-layout"},{default:h(()=>[g]),_:1}),y]),b,e("ol",null,[e("li",null,[e("a",w,[M,t(d)])]),e("li",null,[e("a",_,[I,t(d)])])])],64)}var B=a(m,[["render",x],["__file","memory.html.vue"]]);export{B as default};
