import{_ as s}from"./storage_database.22d441e2.js";import{_ as r,a as l}from"./remote_replication.a56608c2.js";import{_ as h,r as a,o as p,c as u,d as e,a as t,w as c,F as f,b as i,e as o}from"./app.1245c310.js";const m={},w=i('<h1 id="copy" tabindex="-1"><a class="header-anchor" href="#copy" aria-hidden="true">#</a> copy</h1><h2 id="overview" tabindex="-1"><a class="header-anchor" href="#overview" aria-hidden="true">#</a> Overview</h2><p>For the replication of distributed storage, consensus protocols such as Paxos, Raft, and ZAB are commonly used in the industry. More than half of these protocols will sacrifice certain performance to strictly ensure data consistency.</p><p>The scenario faced by <code>LinDB</code> is that the amount of writing is huge, and the requirements for data consistency are not very high. It also allows short-term data inconsistency, but it is eventually consistent. Therefore, <code>LinDB</code> adopts the strategy that the success of writing to the <code>Leader</code> means that the writing is successful.</p><p>Writing to <code>Leader</code> is successful and has the following benefits:</p><ul><li>Can improve write performance;</li><li>Any machine can be deployed in the cluster, while Paxos, Raft, ZAB, etc. require at least 3 machines;</li></ul><p>Writing to <code>Leader</code> is successful, there are the following problems:</p><ul><li>Data consistency problem: once the <code>Leader</code> hangs, a new <code>Leader</code> is elected, and the new <code>Leader</code> copying new data may overwrite the data written by the old <code>Leader</code>;</li><li>Data loss problem: once <code>Leader</code> hangs, and the data block that is not copied to <code>Follower</code> is also damaged at this time, this part of data will be lost;</li></ul><p>In order to solve the above problems and try to ensure that data is not lost, <code>LinDB</code> adopts a multi-channel replication scheme, as shown in the following figure:</p><p><img src="'+s+'" alt="replication"></p><p>Take the data shard <code>Shard 3</code> as an example:</p><ul><li>When <code>Node 1</code> is used as <code>Leader</code>, enable the <code>1-WAL</code> write channel, <code>Node 1</code> receives new data and writes it to the <code>1-WAL</code> channel, and writes the <code>1-wal</code> channel to the <code>1-wal</code> channel The data is copied to the <code>1-WAL</code> channel of <code>Node 2</code> and <code>Node 4</code>;</li><li>When <code>Node 1</code> hangs and <code>Node 2</code> is elected as the new <code>Leader</code>, the <code>2-WAL</code> write channel is enabled, and <code>Node 2</code> receives new data and writes to the <code>2-WAL</code> channel , and copy the data in the <code>2-WAL</code> channel to the <code>2-WAL</code> channel of <code>Node 4</code>;</li><li>When <code>Node 1</code> starts, <code>Node 1</code> will continue to copy the data in the <code>1-WAL</code> channel that has not been copied to <code>Node 2</code> and <code>Node 4</code> to their corresponding <code>1-WAL</code> channels . <code>Node 2</code> will supplement the data in the <code>2-WAL</code> channel to the <code>2-WAL</code> channel of <code>Node 1</code>;</li></ul><p>That is, start the write channel with <code>Leader</code> as the starting point. For example, the <code>1-WAL</code> channel is always the <code>Node 1</code> replication channel to <code>Node 2</code> and <code>Node 4</code>, and the <code>2-WAL</code> channel is always <code>Node 2</code> Duplicate channels to <code>Node 1</code> and <code>Node 4</code>, <code>4-WAL</code> channel is always <code>Node 4</code> duplicate channel to <code>Node 1</code> and <code>Node 2</code>, and so on,</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><code>Node 1</code> corresponds to the unique identifier <code>1</code> in the cluster, and so on for other nodes.</p></div><p>This way of copying solves the following problems:</p><ul><li>Avoid the problem of data inconsistency: only one person is responsible for the authority of the data for each channel, so there will be no conflict;</li><li>Try to avoid the problem of data loss: as long as the data that has not been copied in the old <code>Leader</code> is not lost, it will be copied to other copies after it gets up again. If the data that has not been copied in the old <code>Leader</code> is lost, this part of the data will be lost;</li></ul><p>Preconditions that can be used for multi-channel replication:</p><ul><li>Allow data to be written out of order: data is written to multiple channels and loses its order. The time series data scenarios faced by <code>LinDB</code> do not need to guarantee that transactions can be written out of order.</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Since a major feature of time series data is time correlation, <code>LinDB</code> also shards data by time according to this feature when storing data. Each time shard is a storage unit, so the actual replication channel is also stored with Units correspond one-to-one.</p></div><h2 id="local-copy" tabindex="-1"><a class="header-anchor" href="#local-copy" aria-hidden="true">#</a> local copy</h2><p><img src="'+r+'" alt="local replication"></p><p>The entire local copy writing process is as follows:</p>',22),g=e("li",null,[o("The system will start a write coroutine for each "),e("code",null,"Shard"),o(" replication channel, and this coroutine is responsible for all write operations on this channel, including when it is a "),e("code",null,"Leader"),o(" or "),e("code",null,"Follower"),o(", the coroutine will complete the write operation;")],-1),y=i("First, write the data corresponding to <code>namespace/metric name/tags/fields</code> into the index file of the database, and generate the corresponding <code>metric id/time series id/field id</code>, which mainly completes the conversion of <code>string-&gt;int</code>; The advantage of this is that all data stores are stored in data types to reduce the overall storage size, because for each data point, metadata such as <code>namespace/metric name/tags/fields</code> is occupied, such as <code>cpu{host= 1.1.1.1} load=1 1514214168614</code>, In fact, after converting to <code>id</code>, the storage will be <code>cpu =&gt; 1(metric id), host=1.1.1.1 =&gt; 1(time series id), load =&gt; 1(field id)</code>, simplified to <code>1 1 1514214168614 =&gt;1</code>, please refer to ",17),b=o("index"),_=o(" for the specific index structure;"),L=e("li",null,[o("If the writing of the index fails, it is considered that the writing has failed, and the failure is divided into "),e("code",null,"2"),o("; "),e("ol",null,[e("li",null,"There is a problem with the data writing format, such failures are directly marked as failures;"),e("li",null,"Due to internal problems, the writing fails and needs to be retried;")])],-1),x=o("Write the data into the storage unit through the "),A=e("code",null,"ID",-1),I=o(" obtained by the index, similar to "),v=e("code",null,"LSM",-1),W=o(", write the in-memory database first, and directly write to the memory to achieve high throughput requirements. After the memory data reaches the memory limit, the "),F=e("code",null,"Flush",-1),N=o(" will be triggered For details, please refer to "),k=o("Storage Format"),T=o(", "),q=o("Memory Database"),C=o(";"),R=i('<p>For write operations, you need to pay attention to the following replication <code>Index</code>:</p><ul><li><code>Consume(Replica) Index</code>: where the write coroutine has been processed, each write operation will first verify whether the <code>Index</code> is legal;</li><li><code>Ack Index</code>: which data in this channel has been successfully written and persisted to storage;</li></ul><p>Here are a few things to note:</p><ol><li>The write coroutine will consume the written data from the <code>WAL</code> channel in order, so the <code>Replica Index</code> is an ordered pointer, so it is easier to check with the persisted <code>Index</code> to verify the data whether it has been written;</li><li>The <code>Flush</code> coroutine is used to synchronize the <code>Ack Index</code> to notify which data has been written successfully;</li><li>Since all write operations first write to the memory, and then persist the data in the memory to the corresponding file, if the system crashes during this process, because there is no <code>Ack Index</code>, even if the data in the memory is lost, every write When the coroutine starts, it consumes the data in the <code>WAL</code> channel with <code>Ack Index</code> as the current <code>Replica Index</code>, so it is done, the data can be recovered after the crash;</li></ol><h2 id="remote-copy" tabindex="-1"><a class="header-anchor" href="#remote-copy" aria-hidden="true">#</a> remote copy</h2><p>The above figure <code>Node 1</code> is <code>Leader</code>, <code>3</code> copies to copy <code>1-WAL</code> for example to illustrate:</p><p>Currently <code>Node 1</code> accepts the write of <code>Broker</code> for the <code>Leader</code> of the data shard <code>Shard</code>, <code>Node 2</code> and <code>Node 4</code> are both <code>Follower</code> accepting the replication request of <code>Node 1</code>, at this time The <code>1-WAL</code> channel is used as the current data write channel.</p><p><img src="'+l+'" alt="remote replication"></p><p><code>Index</code> basic concept description:</p><ul><li><code>Append Index</code> of each channel, indicating the location where the channel writes data;</li><li>Each channel retains each <code>Follower Consumer (Replica) Index</code> and <code>Ack Index</code>, respectively indicating the position where each <code>Follower</code> has been consumed (consumed but the request is still on the way, the position has not yet confirmed the successful consumption) and The location where the consumption has been successful;</li><li><code>Tail Index</code> of each channel: indicates the minimum value of all <code>Follower Ack Index</code>, the <code>WAL</code> before the <code>Index</code> can be deleted;</li></ul><p>The entire replication process is as follows:</p><ul><li><code>Leader</code> will start an independent coroutine for each <code>Follower</code> replication, get the data of the <code>Follower Consumer(Replica) Index</code> from <code>WAL</code> of <code>Leader</code> and send it to <code>Follower</code>;</li><li><code>Follower</code> compares the <code>Append Index</code> of the local <code>WAL</code> with the <code>Consumer(Replica) Index</code> after receiving the data; <ul><li>Write if equal and return <code>Consumer Index</code> to <code>Leader</code> as <code>Ack Index</code> (normal case);</li><li>If not equal, return the <code>Append Index</code> of your own local <code>WAL</code> to <code>Leader</code>;</li></ul></li><li>After <code>Leader</code> receives the response, judge whether the <code>Ack Index</code> returned by <code>Follower</code> is equal to <code>Consumer(Replica) Index</code>; <ul><li>if equal to update the <code>Ack Index</code> of the <code>Follower</code> (normal case);</li><li>If it is not equal, it is divided into the following situations: <ul><li>When <code>Follower Ack Index</code> is smaller than <code>Tail Index</code> of <code>Leader WAL</code>, it means that <code>Follower</code> local <code>Append Index</code> is too small, <code>Leader</code> has no data at this position, so <code>Follower</code> needs to be reset Your own <code>Append Index</code> is the <code>Tail Index</code> of <code>Leader</code>;</li><li>When the <code>Follower Ack Index</code> is greater than the <code>Append Index</code> of the <code>Leader WAL</code>, it means that the <code>Append Index</code> of the <code>Follower</code> is too large, and the <code>Leader</code> has no data at this position, and the <code>Leader WAL</code> needs to be changed. Append Index<code>is raised to</code>Follower Ack Index<code>, and </code>Follower Consumer(Replica) Index<code>is raised to</code>Follower Ack Index`;</li><li>When <code>Follower</code> is between <code>Tail Index</code> and <code>Append Index</code> of <code>Leader WAL</code>, you need to reset <code>Follower Consumer(Replica) Index</code> to <code>Follower Ack Index</code>;</li></ul></li></ul></li></ul><p>The process of <code>Leader</code> and <code>Follower</code> to initialize the replication channel is similar to <code>TCP</code> three-way handshake.</p><h2 id="sequential" tabindex="-1"><a class="header-anchor" href="#sequential" aria-hidden="true">#</a> sequential</h2><p>Generally speaking, multi-channel replication does not guarantee the order of the overall data. In most cases, only one of the channels is used. It is necessary to ensure the order of replication of the channel. With order, it is easier to know which data has been copied. Which data has not been replicated.</p><p>To ensure the sequentiality of the replication process, it is necessary to ensure the sequentiality of the following links:</p><ul><li>Sequential sending of <code>Leader</code> copy requests;</li><li>The <code>Follower</code> side processes replication requests sequentially;</li><li>The response of the <code>Leader</code> side to the copy request needs to be guaranteed to be sequential;</li></ul><p>Since the entire writing and copying process is based on the <code>GRPC Stream</code> long connection and single-coroutine processing mechanism, the above conditions can basically be guaranteed.</p><h4 id="refer-to" tabindex="-1"><a class="header-anchor" href="#refer-to" aria-hidden="true">#</a> refer to</h4>',19),B={href:"https://github.com/bulldog2011/bigqueue",target:"_blank",rel:"noopener noreferrer"},D=o("bigqueue");function S(P,E){const d=a("RouterLink"),n=a("ExternalLinkIcon");return p(),u(f,null,[w,e("ul",null,[g,e("li",null,[y,t(d,{to:"/design/index_.html"},{default:c(()=>[b]),_:1}),_]),L,e("li",null,[x,A,I,v,W,F,N,t(d,{to:"/design/storage.html"},{default:c(()=>[k]),_:1}),T,t(d,{to:"/design/memory.html"},{default:c(()=>[q]),_:1}),C])]),R,e("ol",null,[e("li",null,[e("a",B,[D,t(n)])])])],64)}var j=h(m,[["render",S],["__file","replication.html.vue"]]);export{j as default};
