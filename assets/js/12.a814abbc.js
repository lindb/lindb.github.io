(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{33:function(e,t,r){e.exports=r.p+"assets/img/replication.5e465ab4.png"},92:function(e,t,r){"use strict";r.r(t);var o=r(0),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"replication"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#replication"}},[e._v("#")]),e._v(" Replication")]),e._v(" "),o("p",[e._v("The client sends the time series data (including database, metric name, tags, timestamp, fields information) to the broker through the tcp or http protocol. The broker first determines whether the database exists. If exits, calculate the shard number according to the total number of shards configured, metric name, tags, and database, then write the data to the corresponding memory buffer of the shard. When the buffer size exceeds the limit or the write time exceeds the limit, the data in the memory buffer is appended as a record to the disk log file to which the current shard belongs.")]),e._v(" "),o("p",[e._v("A shard according to the configured number of replicas will correspond to one or more physical storage nodes. The broker queries the data in etcd to learn the information, and replicates the records in the shard log file to the corresponding storage node through rpc. According to the current design, the storage directly writes the record data into the memory, and no additional wal is needed. After the in-memory data is written to the disk, the storage informs the broker that this part of the data has been completely consumed through rpc. After all the storage nodes inform the broker consuming records successfully, the broker can delete the disk log file.")]),e._v(" "),o("p",[e._v("The replication process of a shard can be abstracted into the production and consumption process of the Fanout queue. The implementation is inspired by "),o("a",{attrs:{href:"https://github.com/bulldog2011/bigqueue",target:"_blank",rel:"noopener noreferrer"}},[e._v("bigqueue"),o("OutboundLink")],1),e._v(". The broker calculates the shard number of time series data, batches in-memory for efficiency, then write to the Fanout queue, the asynchronous go routine is responsible for pushing the data to the corresponding storage node.")]),e._v(" "),o("p",[o("img",{attrs:{src:r(33),alt:"replication"}})]),e._v(" "),o("p",[e._v("The time series database does not require the sequential writing. As long as the data is finally written, the result of the query is consistent. The sequence is maintained when replicating records from broker to storage in order to ensure accurate data replication under various abnormal scenarios.")]),e._v(" "),o("p",[e._v("Broker replication procedures:")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("The broker consults the index of the storage consumption record. If the index is valid (neighter exceeding the head index currently written by the broker, nor less than the tail index that the broker has already acked), go to step 3, otherwise go to step 2.")])]),e._v(" "),o("li",[o("p",[e._v("Reset the index of the storage with the index recorded by the broker, and proceed to step 3.")])]),e._v(" "),o("li",[o("p",[e._v("Replicate records from the index to the storage, if there is an exception, go back to step 1.")])])]),e._v(" "),o("p",[e._v("Storage replicaiton procedures:")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("Respond to the broker query, reset index request")])]),e._v(" "),o("li",[o("p",[e._v("Receive the record of the push copy of the broker, check whether the index of the record and the index of the storage record are consistent. If yes, return ok, index increments by 1, otherwise it returns an error.")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);