{"pageProps":{"page":{"path":"/docs/lindb/10-design/03-replication.mdx","meta":{"title":"数据复制"},"title":"数据复制","parent":"Design","commitInfo":{"author":"stone1100","date":"Mon Jun 24 07:03:27 2024"}},"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    div: \"div\",\n    h2: \"h2\",\n    h5: \"h5\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    path: \"path\",\n    svg: \"svg\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"概述\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于分布式存储的复制，业界普遍采用的是基于 Paxos、Raft、ZAB 等一致性协议，这些协议的过半确认会牺牲一定性能来严格保证数据的一致性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LinDB 面临的场景是写入量巨大，对数据一致性要求不是很高，也允许短暂的数据不一致，但最终一致，因此 LinDB 采用写入 Leader 成功即写入成功的策略。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"写入 Leader 成功即成功有如下好处：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"可以提高写入性能；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"集群可部署任意台机，而 Paxos、Raft、ZAB 等则要求至少 3 台；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"写入 Leader 成功即成功存在如下问题：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"数据一致性的问题：一旦 Leader 挂了，选举出新的 Leader ，新 Leader 复制新的数据可能会覆盖老 Leader 已写入的数据；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据的丢失问题：一旦 Leader 挂了，而此时正好未复制给 Follower 的数据块也损坏了，则这部分数据会被丢失；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为了解决上述问题，尽量保证数据不丢失， LinDB 采用多通道复制方案，如下图：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/storage_database.png\",\n        alt: \"数据库副本分布\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以数据分片 Shard 3 为例：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"当 Node 1 作为 Leader 时，启用 1-WAL 写入通道， Node 1 接收新的数据写入到 1-WAL 通道中，并把 1-wal 通道中的数据复制到 Node 2 和 Node 4 的 1-WAL 通道中；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"当 Node 1 挂了，选举出 Node 2 作为新的 Leader 时，启用 2-WAL 写入通道，Node 2 接收新的数据写入到 2-WAL 通道中，并把 2-WAL 通道中的数据复制到 Node 4 的 2-WAL 通道中；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"当 Node 1 启动后，Node 1 会把 1-WAL 通道中还未复制给 Node 2 和 Node 4 的数据继续复制到它们对应的 1-WAL 通道中。 Node 2 会把 2-WAL 通道中数据补到 Node 1 的 2-WAL 通道中；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"即以 Leader 为起点开启写入通道，如 1-WAL 通道永远是 Node 1 向 Node 2 和 Node 4 复制通道，2-WAL 通道永远是 Node 2 向 Node 1 和 Node 4 复制通道，4-WAL 通道永远是 Node 4 向 Node 1 和 Node 2 复制通道，以此类推，\"\n    }), \"\\n\", _jsxs(_components.div, {\n      className: \"markdown-alert markdown-alert-tip\",\n      dir: \"auto\",\n      children: [\"\\n\", _jsxs(_components.p, {\n        className: \"markdown-alert-title\",\n        dir: \"auto\",\n        children: [_jsx(_components.svg, {\n          className: \"octicon\",\n          viewBox: \"0 0 16 16\",\n          width: \"16\",\n          height: \"16\",\n          \"aria-hidden\": \"true\",\n          children: _jsx(_components.path, {\n            d: \"M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z\"\n          })\n        }), \"TIP\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Node 1 对应在集群中唯一的标识为 1，其他节点以此类推。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这样的复制方式解决了如下问题：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"避免了数据不一致的问题：每个通道的数据仅仅有一个节点负责数据的权威，所以不会有冲突问题；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"尽量避免数据丢失问题：只要老 Leader 中还未复制的数据没有丢，再次起来后还是会复制到其他副本中。如果老 Leader 中还未复制的数据丢失了则这部分数据会被丢失；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以采用多通道复制的前置条件：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"允许数据乱序写入：数据写入了多通道后就失去了顺序性，LinDB 面临的时序数据场景并不需要保证事务所以是可以乱序写入的。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.div, {\n      className: \"markdown-alert markdown-alert-tip\",\n      dir: \"auto\",\n      children: [\"\\n\", _jsxs(_components.p, {\n        className: \"markdown-alert-title\",\n        dir: \"auto\",\n        children: [_jsx(_components.svg, {\n          className: \"octicon\",\n          viewBox: \"0 0 16 16\",\n          width: \"16\",\n          height: \"16\",\n          \"aria-hidden\": \"true\",\n          children: _jsx(_components.path, {\n            d: \"M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z\"\n          })\n        }), \"TIP\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"由于时序数据一大特点是时间相关性，所以 LinDB 在存储数据的时候也根据这一特点按时间进行分片，每个时间分片为一个存储单元，因此实际的复制道通也跟存储单元一一对应。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"本地复制\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/lindb/design/local_replication.png\",\n        alt: \"副本本地复制\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个本地复制写入过程如下：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"系统会为每一个 Shard 复制通道启一个写协程，该协程负责这个通道的所有写操作，包括作为 Leader 或者 Follower 时都有该协程来完成写操作；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"首先把 namespace/metric name/tags/fields 对应的数据写入数据库的索引文件，并生成相应的 metric id/time series id/field id，主要完成 string->int 的转换；这样的好处是所有的数据存储都以数据类型来存储，以减少整体存储大小，因为对于每个数据点，namespace/metric name/tags/fields 这样元数据所占用，如 cpu{host=1.1.1.1} load=1 \", _jsx(_components.a, {\n          href: \"https://github.com/lindb/lindb/commit/1514214168614\",\n          children: _jsx(_components.code, {\n            children: \"1514214\"\n          })\n        }), \"，\\n其实转换成 id 之后，存储将由 cpu => 1(metric id), host=1.1.1.1 => 1(time series id), load => 1(field id)，简化为 1 1 \", _jsx(_components.a, {\n          href: \"https://github.com/lindb/lindb/commit/1514214168614\",\n          children: _jsx(_components.code, {\n            children: \"1514214\"\n          })\n        }), \"=>1，具体的索引结构请查看\", _jsx(_components.a, {\n          href: \"/docs/lindb/design/inverted-index\",\n          children: \"索引\"\n        }), \"；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"如果写索引失败，认为本次写入失败，失败分为 2 种；\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"数据写入格式有问题，这类失败直接标示失败；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"由于内部问题，这时写入失败需要重试；\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"通过索引得到 ID 后，再将数据写入到存储单元中，类似 LSM 先写内存数据库，直接写内存以达到高吞吐量的要求，内存数据到达内存限制之后，会触发 Flush 操作，具体请查看\", _jsx(_components.a, {\n          href: \"/docs/lindb/design/storage\",\n          children: \"存储格式\"\n        }), \"、\", _jsx(_components.a, {\n          href: \"/docs/lindb/design/memory-database\",\n          children: \"内存数据库\"\n        }), \"；\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于写操作，需要注意如下几个复制 Index:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Consume(Replica) Index: 写协程已经处理到哪个位置，每写操作都会先验证该 Index 是否合法；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Ack Index: 该通道中哪些数据已经写入成功并持久化到存储中；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这里需要注意如下几点：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"写协程会按顺序从 WAL 通道中消费写入的数据，因此 Replica Index 是一个有序的指针，因此比较容易与已经持久化的 Index 作校验，以验证数据是否已经被写入；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"由 Flush 协程来同步 Ack Index 通知哪些数据已经写入成功；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"由于所有的写入操作先写内存，再由内存中的数据持久化到相应文件中，在这个过程中如果系统 Crash，由于没有 Ack Index，即使内存中数据丢失，但每次写协程启动的时候都以 Ack Index 为当前 Replica Index 来消费 WAL 通道中的数据，所以做到了在 Crash 之后也可以恢复丢失的数据；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"远程复制\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以上图 Node 1 为 Leader，3 个副本来复制 1-WAL 举例来说明：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当前 Node 1 为该数据分片 Shard 的 Leader 接受 Broker 的写入，Node 2 和 Node 4 都是 Follower 接受 Node 1 的复制请求，此时 1-WAL 通道作为当前的数据写入通道。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/img/lindb/design/remote_replication.png\",\n        children: \"副本远程复制\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Index 基本概念说明：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"每个通道的 Append Index，表示该通道写入数据的位置；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"每个通道保留着每个 Follower Consumer(Replica) Index 和 Ack Index，分别表示每个 Follower 已消费的位置（已消费但是请求还在路上该位置还未确认消费成功）和消费已成功的位置；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"每个通道的 Tail Index：表示所有 Follower Ack Index 的最小值，该 Index 之前的 WAL 可以被删除了；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整个复制流程如下所示：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Leader 会为每个 Follower 的复制启动一个独立的协程进行处理，从 Leader 的 WAL 中获取该 Follower Consumer(Replica) Index 的数据发给 Follower ；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Follower 接收到数据后对比本地 WAL 的 Append Index 是否等于 Consumer(Replica) Index；\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"如果等于则写入并将 Consumer Index 作为 Ack Index 返回给 Leader（正常情况下）；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"如果不等于，则将自己本地 WAL 的 Append Index 返回给 Leader；\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Leader 接收到响应之后，判断 Follower 返回的 Ack Index 是否等于 Consumer(Replica) Index；\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"如果等于则更新该 Follower 的 Ack Index（正常情况下）;\"\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"如果不等于，则分如下几种情况：\", \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: \"当 Follower Ack Index 小于 Leader WAL 的 Tail Index ，说明 Follower 本地的 Append Index 过小，Leader 已无该位置的数据了，所以需要 Follower 重置下自己的 Append Index 为 Leader 的 Tail Index ；\"\n              }), \"\\n\", _jsx(_components.li, {\n                children: \"当 Follower Ack Index 大于 Leader WAL 的 Append Index ，说明 Follower 本地的 Append Index 过大，Leader 已无该位置的数据了，需要将 Leader WAL 的 Append Index 提高到 Follower Ack Index ，同时将 Follower Consumer(Replica) Index 提高到 Follower Ack Index;\"\n              }), \"\\n\", _jsx(_components.li, {\n                children: \"当 Follower 在 Leader WAL 的 Tail Index 和 Append Index 之间，则需要将 Follower Consumer(Replica) Index 重置为 Follower Ack Index 即可；\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Leader 与 Follower 初始化复制通道的过程类似 TCP 三次握手。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"顺序性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"多通道复制总体来说是不保证整体数据的顺序性，绝大多情况下只使用其中的某一个通道，需保证该通道的复制的顺序性，有了顺序性更容易知道哪些数据已经被复制了哪些数据还未被复制。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"要想保证复制过程的顺序性，需要保证以下几个环节的顺序性：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Leader 复制请求的顺序性发送；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Follower 端对复制请求的处理是顺序性；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Leader 端对复制请求的响应需要保证是顺序性；\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由于整个写入与复制过程都是基于 GRPC Stream 长连接加单协程处理机制，因此基本可以保证上述几个条件。\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"参考\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/bulldog2011/bigqueue\",\n          children: \"bigqueue\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"tocItems":[{"id":"概述","level":2,"title":"概述"},{"id":"本地复制","level":2,"title":"本地复制"},{"id":"远程复制","level":2,"title":"远程复制"},{"id":"顺序性","level":2,"title":"顺序性"}],"releases":null,"sidebar":[{"index":2,"title":"Getting Started","children":[{"index":1,"title":"Docker","children":[],"href":"/docs/lindb/getting-started/docker"},{"index":2,"title":"安装包","children":[],"href":"/docs/lindb/getting-started/package"}]},{"index":3,"title":"Developer Guide","children":[{"index":1,"title":"建立连接","children":[],"href":"/docs/lindb/developer-guide/connect"},{"index":2,"title":"创建数据库","children":[],"href":"/docs/lindb/developer-guide/create-database"},{"index":3,"title":"写入数据","children":[],"href":"/docs/lindb/developer-guide/insert-data"},{"index":4,"title":"查询数据","children":[],"href":"/docs/lindb/developer-guide/query-data"}]},{"index":4,"title":"Deployment","children":[{"index":1,"title":"Kubernetes","children":[],"href":"/docs/lindb/deployment/kubernetes"},{"index":2,"title":"手动部署","children":[],"href":"/docs/lindb/deployment/manual"}]},{"index":5,"title":"Client","children":[{"index":1,"title":"CLI","children":[],"href":"/docs/lindb/client/cli"},{"index":2,"title":"客户端 SDK","children":[],"href":"/docs/lindb/client/client-libraries"},{"index":3,"title":"Go","children":[],"href":"/docs/lindb/client/go"},{"index":4,"title":"Java","children":[],"href":"/docs/lindb/client/java"}]},{"index":6,"title":"Lin Ql","children":[{"index":1,"title":"SQL","children":[],"href":"/docs/lindb/lin-ql/sql"}]},{"index":7,"title":"Admin Console","children":[{"index":1,"title":"简介","children":[],"href":"/docs/lindb/admin-console/index"},{"index":2,"title":"集群状态","children":[],"href":"/docs/lindb/admin-console/overview"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/admin-console/search"},{"index":4,"title":"数据浏览","children":[],"href":"/docs/lindb/admin-console/explore"},{"index":5,"title":"监控","children":[],"href":"/docs/lindb/admin-console/monitoring"},{"index":6,"title":"元数据","children":[],"href":"/docs/lindb/admin-console/metadata"}]},{"index":8,"title":"Api","children":[{"index":1,"title":"介绍","children":[],"href":"/docs/lindb/api/index"},{"index":2,"title":"数据写入","children":[],"href":"/docs/lindb/api/insert"},{"index":3,"title":"数据查询","children":[],"href":"/docs/lindb/api/query"},{"index":4,"title":"集群状态","children":[],"href":"/docs/lindb/api/state"}]},{"index":9,"title":"Reference","children":[{"index":1,"title":"数据模型","children":[],"href":"/docs/lindb/reference/data-model"},{"index":2,"title":"Metric","children":[],"href":"/docs/lindb/reference/metric"},{"index":3,"title":"配置参数","children":[],"href":"/docs/lindb/reference/configuration"}]},{"index":10,"title":"Design","children":[{"index":1,"title":"架构","children":[],"href":"/docs/lindb/design/architecture"},{"index":2,"title":"集群协调","children":[],"href":"/docs/lindb/design/coordinator"},{"index":3,"title":"数据复制","children":[],"href":"/docs/lindb/design/replication"},{"index":4,"title":"查询","children":[],"href":"/docs/lindb/design/query"},{"index":5,"title":"存储","children":[],"href":"/docs/lindb/design/storage"},{"index":6,"title":"内存数据库","children":[],"href":"/docs/lindb/design/memory-database"},{"index":7,"title":"例排索引","children":[],"href":"/docs/lindb/design/inverted-index"}]}],"locale":"zh","_nextI18Next":{"initialI18nStore":{"zh":{"translation":{"A lightweight, observability pipeline":"轻量级数据处理平台","A single server could easily support more than one million write TPS.":"机支持百万以上TPS写入；","Admin Console":"控制台","All-in-one observability platform":"一站式可观测平台","An open-source, cloud native, horizontally scalable, distributed time-series database.":"一款开源分布式时序数据库，具有高性能、高可用性和水平扩展性","An open-source, cloud native, observabilty platform":"云原生开源可观测平台","Architecture":"整体架构","Ask a Question":"提问","Auto Rollup":"自动 Rollup","Bug report":"发现 Bug","Client":"客户端","Cross Multiple IDCs":"跨多数据中心","Deployment":"集群部署","Design":"设计","Developer Guide":"开发手册","Distributed time-series database":"分布式时序数据库","Docs":"文档","Documentation":"文档","Downloads":"下载","Easy to use":"简单易用","Edit this page on Github":"在 GitHub 上编辑此页","Feature request":"新需求","Get Help":"获取帮助","Getting Started":"快速开始","High availability":"高可用","High performance":"高性能","Horizontal scalability":"水平扩展","Horizontal scalable is made simple by adding more new broker and storage nodes without too much thinking and manual operations Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Tags 级别的 Sharding 机制，可将任一 Metric 数据充分分散到多个存储节点；","Insert data":"数据写入","Inside LinDB":"技术内幕","Introduction":"介绍","Inverted index":"例排索引","Key Features":"主要功能","Learn More":"更多","License":"许可证","LinDB is designed to work under a Multi-Active IDCs cloud architecture. The compute layer of LinDB, called brokers, supports efficient Multi-IDCs aggregation query.":"支持各数据中心写入，多数据中心查询聚合；","LinDB supports rollup in specific intervals(minute, hour and day) automatically after creating the database(unlike the Continuous-Query of InfluxDB).":"支持秒级数据写入后自动Rollup到分钟、小时和天的粒度，无需人工介入（如 InfluxDB Continuous-Query）；","On this page":"本页导航","Open source":"开源","Query data":"数据查询","Read the installation guide for more information":{"":"查看安装手册了解更多信息。"},"Reference":"参考手册","Release Date":"发布时间","Release Note":"发布日志","Releases":"变更日志","Resources":"资源","Schema-free multi-dimensional data model with Metric, Tags, and Fields.":"支持 Metric + Tags + Fields 的方式，无需提前定义 Schema；","Storage":"存储","Tags-based sharding strategy resolves the hotspot problem":"充分解决热点问题，可通过增加服务器数量线性增加处理能力；","The LinQL is flexible yet handy for real-time data analytics.":"可通过 LinQL 进行实时数据分析；","The multi-channel replication protocol supports any amount of nodes, ensures the system availability.":"独创的多通道复制协议支持任意节点数的多副本机制，可保证整个服务的高可用性；","This page could not be found":"找不到此页面","Uncompress":"解压","Version":"版本","View on GitHub":"GitHub","What's LinDB?":"什么是 LinDB？","What's New in":"","Why LinDB?":"为什么选择 LinDB？","With fundamental techniques like efficient compression storage and parallel computing, LinDB delivers highly optimized query performance.":"高效的数据压缩与多节点的并行查询与计算，专注查询性能优化；"}},"en":{"translation":{"Lin Ql":"Lin QL","Api":"API"}}},"initialLocale":"zh","ns":["translation"],"userConfig":null}},"__N_SSG":true}